//
// DPC2: Region-Based Offset Prefetcher (Corrected and Improved)
//
#include "cache.h"
#include <vector>

//================================================================================
// Constants and Definitions
//================================================================================
#define PAGE_TRACKER_TABLE_SIZE 256
#define MAX_OFFSETS_PER_PAGE 5
#define PREFETCH_METADATA_TAG (1 << 30)

//================================================================================
// Data Structures
//================================================================================
struct OffsetFrequency
{
    int64_t offset_value;
    uint32_t frequency;
};

struct PageAccessTracker
{
    bool valid;
    uint64_t page_address_tag;
    uint64_t last_address;

    OffsetFrequency offsets[MAX_OFFSETS_PER_PAGE];

    uint32_t prefetches_issued;
    uint32_t prefetches_useful;

    uint32_t lru_counter;
};

//================================================================================
// Global Variables
//================================================================================
PageAccessTracker PageTrackerTable[PAGE_TRACKER_TABLE_SIZE];

//================================================================================
// Prefetcher Functions
//================================================================================
void CACHE::l2c_prefetcher_initialize()
{
    cout << "CPU " << cpu << " L2C Region-Based Offset Prefetcher (Corrected) initialized." << endl;
    for (int i = 0; i < PAGE_TRACKER_TABLE_SIZE; ++i)
    {
        PageTrackerTable[i].valid = false;
        PageTrackerTable[i].page_address_tag = 0;
        PageTrackerTable[i].last_address = 0;
        PageTrackerTable[i].prefetches_issued = 0;
        PageTrackerTable[i].prefetches_useful = 0;
        PageTrackerTable[i].lru_counter = i;

        for (int j = 0; j < MAX_OFFSETS_PER_PAGE; ++j)
        {
            PageTrackerTable[i].offsets[j].offset_value = 0;
            PageTrackerTable[i].offsets[j].frequency = 0;
        }
    }
}

uint32_t CACHE::l2c_prefetcher_operate(uint64_t addr, uint64_t ip, uint8_t cache_hit, uint8_t type, uint32_t metadata_in, uint8_t critical_ip_flag)
{
    uint64_t current_page_address = addr >> LOG2_PAGE_SIZE;
    int tracker_index = -1;

    for (int i = 0; i < PAGE_TRACKER_TABLE_SIZE; ++i)
    {
        if (PageTrackerTable[i].valid && PageTrackerTable[i].page_address_tag == current_page_address)
        {
            tracker_index = i;
            break;
        }
    }

    if (tracker_index == -1)
    {
        for (int i = 0; i < PAGE_TRACKER_TABLE_SIZE; ++i)
        {
            if (PageTrackerTable[i].lru_counter == (PAGE_TRACKER_TABLE_SIZE - 1))
            {
                tracker_index = i;
                break;
            }
        }

        PageAccessTracker &victim_tracker = PageTrackerTable[tracker_index];
        victim_tracker.valid = true;
        victim_tracker.page_address_tag = current_page_address;
        victim_tracker.last_address = addr;
        victim_tracker.prefetches_issued = 0;
        victim_tracker.prefetches_useful = 0;
        for (int j = 0; j < MAX_OFFSETS_PER_PAGE; ++j)
        {
            victim_tracker.offsets[j].offset_value = 0;
            victim_tracker.offsets[j].frequency = 0;
        }
    }
    else
    {
        PageAccessTracker &tracker = PageTrackerTable[tracker_index];
        int64_t offset = addr - tracker.last_address;

        if (offset != 0)
        {
            bool offset_found = false;
            int min_freq_index = 0;
            uint32_t min_freq = tracker.offsets[0].frequency;

            // CORRECTED: This loop now correctly finds the least frequent entry.
            for (int i = 0; i < MAX_OFFSETS_PER_PAGE; ++i)
            {
                if (tracker.offsets[i].offset_value == offset)
                {
                    tracker.offsets[i].frequency++;
                    offset_found = true;
                    break;
                }
                if (tracker.offsets[i].frequency < min_freq)
                {
                    min_freq = tracker.offsets[i].frequency;
                    min_freq_index = i;
                }
            }

            if (!offset_found)
            {
                tracker.offsets[min_freq_index].offset_value = offset;
                tracker.offsets[min_freq_index].frequency = 1;
            }

            // --- ACCURACY AND ADAPTATION LOGIC (TUNED FOR BETTER PERFORMANCE) ---
            int prefetch_degree = 1;
            if (tracker.prefetches_issued > 20)
            { // Increased warm-up period
                double accuracy = (double)tracker.prefetches_useful / tracker.prefetches_issued;
                if (accuracy > 0.8)
                {
                    prefetch_degree = 4; // More aggressive
                }
                else if (accuracy > 0.5)
                {
                    prefetch_degree = 2;
                }
            }

            int64_t best_offset = tracker.offsets[0].offset_value;
            uint32_t max_freq = tracker.offsets[0].frequency;
            for (int i = 1; i < MAX_OFFSETS_PER_PAGE; ++i)
            {
                if (tracker.offsets[i].frequency > max_freq)
                {
                    max_freq = tracker.offsets[i].frequency;
                    best_offset = tracker.offsets[i].offset_value;
                }
            }

            for (int i = 1; i <= prefetch_degree; ++i)
            {
                uint64_t prefetch_address = addr + (best_offset * i);
                if ((prefetch_address >> LOG2_PAGE_SIZE) != current_page_address)
                {
                    break;
                }

                // CORRECTED: Pass the actual PREFETCH_METADATA_TAG to enable accuracy checking.
                if (MSHR.occupancy < (MSHR.SIZE >> 1))
                    prefetch_line(ip, addr, prefetch_address, FILL_L2, PREFETCH_METADATA_TAG);
                else
                    prefetch_line(ip, addr, prefetch_address, FILL_LLC, PREFETCH_METADATA_TAG);

                tracker.prefetches_issued++;
            }
        }
        tracker.last_address = addr;
    }

    uint32_t current_lru = PageTrackerTable[tracker_index].lru_counter;
    for (int i = 0; i < PAGE_TRACKER_TABLE_SIZE; ++i)
    {
        if (PageTrackerTable[i].lru_counter < current_lru)
        {
            PageTrackerTable[i].lru_counter++;
        }
    }
    PageTrackerTable[tracker_index].lru_counter = 0;

    return metadata_in;
}

uint32_t CACHE::l2c_prefetcher_cache_fill(uint64_t addr, uint32_t set, uint32_t match, uint8_t prefetch, uint64_t evicted_addr, uint32_t metadata_in)
{
    // CORRECTED: The check for a useful prefetch is now working.
    // It triggers on a DEMAND access (!prefetch) that HITS a line with OUR tag.
    if (!prefetch && (metadata_in & PREFETCH_METADATA_TAG))
    {
        uint64_t page_address = addr >> LOG2_PAGE_SIZE;
        for (int i = 0; i < PAGE_TRACKER_TABLE_SIZE; ++i)
        {
            if (PageTrackerTable[i].valid && PageTrackerTable[i].page_address_tag == page_address)
            {
                PageTrackerTable[i].prefetches_useful++;
                break;
            }
        }
    }
    return metadata_in;
}

void CACHE::l2c_prefetcher_final_stats() {}
